import java.awt.image.BufferedImage;
import java.awt.image.PixelGrabber;
import java.io.*;
import javax.imageio.ImageIO;

class Stego {
    public static void main(String[] args) {
        // Initialize variables
        BufferedImage ogImg = null;
        BufferedImage qrCode = null;
        BufferedImage stegoImg = null;
        BufferedImage qrImg = null;
        // Try to read image from file path given
        try {
            ogImg = ImageIO.read(new File(args[0]));
            // TODO: Generate a qr code
            // DUMMY QR CODE, NEED TO HOOK IT UP
            qrCode = ImageIO.read(new File(args[1]));
        } catch (IOException e) {
            System.err.println("Error opening image.");
        }
        // Conversion Process
        try {
            // Encode test
            stegoImg = encode(ogImg, qrCode);
            boolean success = ImageIO.write(stegoImg, "png", new File("stegoImg.png"));
            if (!success) {
                System.err.println("Error writing encoded image to device");
            }
            // Decode test
            qrImg = decode(stegoImg, qrCode);
            success = ImageIO.write(qrImg, "png", new File("qrDecode.png"));
            if (!success) {
                System.err.println("Error writing decoded image to device");
            }
            // Decode
        } catch (Exception e) {
            System.err.println(e);
            System.err.println("Error merging images.");
        }
    }

    public static BufferedImage encode(BufferedImage ogImg, BufferedImage qrCode) {
        int[] ogPixels = new int[ogImg.getWidth() * ogImg.getHeight()];
        PixelGrabber ogChewer = new PixelGrabber(ogImg, 0, 0, ogImg.getWidth(), ogImg.getHeight(), ogPixels, 0, ogImg.getWidth());
        int[] qrPixels = new int[qrCode.getWidth() * qrCode.getHeight()];
        PixelGrabber qrChewer = new PixelGrabber(qrCode, 0, 0, qrCode.getWidth(), qrCode.getHeight(), qrPixels, 0, qrCode.getWidth());
        int[] stegoPixels = new int[ogImg.getWidth() * ogImg.getHeight()];
        BufferedImage stegoImg = null;
        try {
            ogChewer.grabPixels();
            qrChewer.grabPixels();
        } catch (Exception e) {
            System.err.println("Error grabbing pixels during encoding.");
        }
        // Using pixel data and image dimensions, write the qr code information into the red channel of image
        for (int j = 0; j < ogImg.getHeight(); j++) {
            for (int i = 0; i < ogImg.getWidth(); i++) {
                if ((j * ogImg.getWidth() + i) < qrPixels.length) {
                    stegoPixels[j * ogImg.getWidth() + i] = encodeSinglePixel(ogPixels[j * ogImg.getWidth() + i], qrPixels[j * ogImg.getWidth() + i]);
                } else {
                    stegoPixels[j * ogImg.getWidth() + i] = ogPixels[j * ogImg.getWidth() + i];
                }
            }
        }
        stegoImg = arrayToImage(stegoPixels, ogImg.getWidth(), ogImg.getHeight());
        return stegoImg;
    }

    public static int encodeSinglePixel(int ogPixel, int qrPixel) {
        // Split pixel into separate channels
        int ogAlpha = (ogPixel >> 24) & 0xff;
        int ogRed   = (ogPixel >> 16) & 0xff;
        int ogGreen = (ogPixel >> 8) & 0xff;
        int ogBlue = (ogPixel) & 0xff;
        int qrRed = (qrPixel >> 16) & 0xff;
        // Convert pixel int values to binary
        String ogRedBits = Integer.toBinaryString(ogRed);
        String ogBlueBits = Integer.toBinaryString(ogBlue);
        String ogGreenBits = Integer.toBinaryString(ogGreen);
        String qrRedBits = Integer.toBinaryString(qrRed);
        // Check if the qr pixel is black or white, otherwise throw error
        // Append a 1 or 0 to the new pixel, depending on the qr code pixel value
        String newPixelRedBits = blackOrWhiteMerge(ogRedBits, qrRedBits);
        String newPixelBlueBits = blackOrWhiteMerge(ogBlueBits, qrRedBits);
        String newPixelGreenBits = blackOrWhiteMerge(ogGreenBits, qrRedBits);
        // Convert pixel binary values to int
        int newPixelRed = Integer.parseInt(newPixelRedBits,2);
        int newPixelBlue = Integer.parseInt(newPixelBlueBits,2);
        int newPixelGreen = Integer.parseInt(newPixelGreenBits,2);
        // Combine separate channels into a pixel
        return ((ogAlpha << 24) | (newPixelRed << 16) | (newPixelGreen << 8) | (newPixelBlue));
    }

    public static BufferedImage decode(BufferedImage stegoImg, BufferedImage dummy) {
        // Using qrCode image to get width and height at the moment
        // Ideally, used fixed size with qr code generator, then hardcode those values in loops
        int[] stegoPixels = new int[stegoImg.getWidth() * stegoImg.getHeight()];
        PixelGrabber stegoChewer = new PixelGrabber(stegoImg, 0, 0, stegoImg.getWidth(), stegoImg.getHeight(), stegoPixels, 0, stegoImg.getWidth());
        int[] qrPixels = new int[dummy.getWidth() * dummy.getHeight()];
        BufferedImage qrCode = null;
        try {
            stegoChewer.grabPixels();
        } catch (Exception e) {
            System.err.println("Error grabbing pixels during decoding.");
        }
        // Using pixel data and image dimensions, write the qr code information into the red channel of image
        for (int j = 0; j < stegoImg.getHeight(); j++) {
            for (int i = 0; i < stegoImg.getWidth() && ((j * stegoImg.getWidth() + i) < qrPixels.length); i++) {
                qrPixels[j * stegoImg.getWidth() + i] = decodeSinglePixel(stegoPixels[j * stegoImg.getWidth() + i]);
            }
        }
        qrCode = arrayToImage(qrPixels, dummy.getWidth(), dummy.getHeight());
        return qrCode;
    }

    public static int decodeSinglePixel(int stegoPixel) {
        // Will return white pixel by default
        int qrPixel = 0;
        // Each pixel contains the information, so we only need to check one
        int stegoRed   = (stegoPixel >> 16) & 0xff;
        // Convert pixel int value to binary
        String stegoRedBits = Integer.toBinaryString(stegoRed);
        // Check for black or white
        if (stegoRedBits.charAt(stegoRedBits.length()-1) == '1') {
            qrPixel = 255;
        }
        return ((255 << 24) | (qrPixel << 16) | (qrPixel << 8) | (qrPixel));
    }

    public static String blackOrWhiteMerge(String ogPixelBits, String qrPixelBits) {
        StringBuilder sb = new StringBuilder();
        sb.append(ogPixelBits);
        // Leading zeros aren't always included, this loop will correct that
        while (sb.length() <= 8) {
            sb.insert(0, '0');
        }
        ogPixelBits = sb.toString();
        sb.setLength(0);
        if (qrPixelBits.equals("11111111")) {
            sb.append(ogPixelBits.substring(0,8));
            sb.append(1);
        } else if (qrPixelBits.equals("0")) {
            sb.append(ogPixelBits.substring(0,8));
            sb.append(0);
        } else {
            System.err.println("Corrupted QR data detected.");
        }
        return sb.toString();
    }

    public static BufferedImage arrayToImage(int[] stegoPixels, int width, int height) {
        BufferedImage stegoImg = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB_PRE);
        stegoImg.setRGB(0, 0, width, height, stegoPixels, 0, width);
        return stegoImg;
    }
}